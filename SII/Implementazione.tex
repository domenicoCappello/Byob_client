\chapter{Implementazione}
\label{chap:implementazione}
\begin{minipage}{12cm}\textit{Sono di seguito presentati dettagli riguardanti l'implementazione dei passi principali eseguiti dal programma in esame. }
\end{minipage}

\section{Avvio iniziale}
All'avvio dell'applicazione, viene visualizzata la schermata principale di configurazione; vengono inoltre raccolte e scritte sul file \textit{sys\_info.txt} informazioni riguardanti il sistema operativo della macchina e le versioni dei browser installati.

\vspace{0.5cm}
\begin{lstlisting}
public class Byob_v1 {

	public static void main(String[] args) {
		/**Start the GUI*/
		GUI frame = new GUI();
		final Toolkit toolkit = Toolkit.getDefaultToolkit();
		final Dimension screenSize = toolkit.getScreenSize();
		int x = (screenSize.width - frame.getWidth()) / 2;
		int y = (screenSize.height - frame.getHeight()) / 2;
		frame.setTitle("BYOB v_1");
		frame.setLocation(x, y);
		frame.setVisible(true);
		/**Gather system informations and write them on sys_info.txt*/
		Tools.writeInfoFile("sys_info.txt");
	}

}
\end{lstlisting}

\section{Informazioni di sistema}

Il sistema operativo in esecuzione sulla macchina \`{e} restituito dalla funzione \textit{Tools.getOs()}.

\vspace{0.5cm}
\begin{lstlisting}
    public static String getOs(){
	    return System.getProperty("os.name");
    }
\end{lstlisting}

Per riuscire ad identificare i browser installati, sono state adottate strategie differenti per ogni sistema operativo individuato;
la funzione \textit{Tools.getBrowsers()} invoca \textit{Tools.getOs()} e distingue le azioni da intraprendere:

\vspace{0.5cm}
\begin{lstlisting}
public static String getBrowsers(){

	String browsers = "";
	String os = getOs().toLowerCase();
	if(os.contains("linux")){
		[...]
	} else if(os.contains("windows")){
		[...]
	} else if(os.contains("mac")){
		[...]
	} else {
		/**Couldn't recognize OS*/
	}
	return browsers;
\end{lstlisting}

\subsection{Linux}
I browser ritenuti pi\`{u} comuni in ambiente linux sono stati:
\begin{itemize}
	\item Google Chrome
	\item Mozilla Firefox
	\item Opera
	\item Chromium
\end{itemize}
Per identificare l'eventuale versione installata di ogni browser, viene avviato un nuovo processo che esegue la \textit{bash} invocando il programma relativo ad ogni browser con il parametro -\textit{-version}.

\vspace{0.5cm}
\begin{lstlisting}
	[...]
	String tmp = unixTermOut("firefox --version");
	[...]

private static String unixTermOut(String cmd){
    String[] args = new String[] {"/bin/bash", "-c", cmd};
    String out = "";
    try {
	    Process proc = new ProcessBuilder(args).start();
	    BufferedReader br = new BufferedReader(
	    new InputStreamReader(proc.getInputStream()));
	    out = br.readLine();
    } catch (IOException ex) {
	    [...]
    }
    return out;
   }
\end{lstlisting}

\subsection{Windows}
I browser ritenuti pi\`{u} comuni in ambiente linux sono stati:
\begin{itemize}
	\item Internet Explorer
	\item Google Chrome
	\item Mozilla Firefox
\end{itemize}
Per individuare in modo sistematico le versioni installate, si \`{e} scelto di interrogare il registro di sistema di Windows.
Ci\`{o} \`{e} stato possibile grazie all'utilizzo di una libreria esterna, la
\textit{Java Native Access}\footnote{https://github.com/java-native-access/jna\#readme}, in cui il package \textit{com.sun.jna.platform.win32.Advapi32Util} offre un'interfaccia semplice e immediata per l'accesso e la manipolazione dei registri di sistema.

\vspace{0.5cm}
\begin{lstlisting}
[...]
String path = "SOFTWARE\\Microsoft\\Internet Explorer";
String vField = getOs().toLowerCase().equals("windows 8")? "svcVersion" : 	 "Version";
String version = Advapi32Util.registryGetStringValue(   
WinReg.HKEY_LOCAL_MACHINE, path, vField);
[...]
\end{lstlisting}

\subsection{Mac OSx}
I browser ritenuti pi\`{u} comuni in ambiente \textit{Mac OSx} sono stati:
\begin{itemize}
	\item Google Chrome
	\item Mozilla Firefox
	\item Opera
	\item Safari
\end{itemize}
Come per \textit{Linux}, per identificare l'eventuale versione installata di ogni browser, viene avviato un nuovo processo che esegue la shell di sistema avviando il programma \textit{system\_profiler} con parametro \textit{SPApplicationDataType}. L'output offerto dal profiler di sistema contiene al suo interno tutto il software installato sulla macchina, compreso numero di versione e autori. 
Tutte le informazioni vengono salvate all'interno del file \textit{mac\_profile.txt}, da cui successivamente vengono estratte le versioni relative al software cercato.

\vspace{0.5cm}
\begin{lstlisting}
[...]
linuxTermOut("system_profiler SPApplicationDataType > mac_profile.txt");
[...]
String[] args = new String[] {"/bin/bash", "-c", "grep 
-e \"Google Chrome:\" -e \"Firefox:\" -e \"  Opera:\" -e \"Safari:\" 
-A 2 mac_profiler.txt"};
String str = linuxTermOut(args);
\end{lstlisting}

\section{File di configurazione}
Il file di configurazione permette di impostare i parametri principali delle comunicazioni da effettuare verso l'esterno.
Per ogni contatto \`{e} necessario definire una URL, la periodicit\`{a} di contatto (che pu\`{o} essere fissa o scelta randomicamente in un intervallo pre-impostato), il numero massimo dei contatti da effettuare.
\`{E} inoltre possibile impostare un proxy tramite il quale effettuare le connessioni, uno \textit{user agent} differente da quello di default ed un set di condizione sotto le quali non viene effettuata la connessione alla URL specificata.

Il file di configurazione consiste in un file di testo formattato nel seguente modo:

\vspace{0.5cm}
\begin{lstlisting}
	$proxy_ip:proxy_port /**Opzionale*/
	*URL_1
	minimo_intervallo_di_contatto
	massimo_intervallo_di_contatto
	numero_di_contatti_effettuabili
	condizioni_di_sleep
	user_agent
	*URL_2
	[...]
\end{lstlisting}

\subsection{Immissione e scrittura}

Torniamo all'analisi della GUI.\\


Nel caso di scelta di inserimento manuale dei parametri di configurazione, l'interfaccia mette a disposizioni delle \textit{jFormattedTextField}. Esse rappresentano un modo facile per specificare l'insieme di caratteri che possono essere accettati tramite un "formattatore": nel caso di campi numerici come \textit{Contact Time}, \textit{\# contacts} e la porta del \textit{proxy} \`{e} stato utilizzato \textit{NumberFormatter}, il quale accetta come input alla creazione una classe \textit{abstract} chiamata \textit{NumberFormat}, la quale fornisce un'interfaccia per formattare e parsare correttamente i numeri; nel caso del campo IP del \textit{proxy}, \`{e} stato utilizzata una classe finale \textit{RegexFormatter} che estende la classe \textit{Default Formatter}. Tale estensione si \`{e} resa necessaria in quanto il campo IP richiedeva un determinato \textit{pattern}, ossia quello xxx.xxx.xxx.xxx dove "xxx" Ã¨ compreso tra 0 e 255. Per tutte le altre non si \`{e} reso necessario nessun \textit{format} preciso, in quanto stringhe.


Dapprima, viene costruita una espressione regolare che specifichi il tipo di \textit{input}:


\vspace{0.5cm}

\begin{lstlisting}

String _255 = "(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";

\end{lstlisting}


\begin{itemize}

\item "?:" specifica che la restante espressione non \`{e} parte di un gruppo "cattura"\footnote{Nelle espressioni regolari, l'utilizzo di parentesi tonde o quadre permette di specificare "gruppi", il cui vantaggio \`{e} poter applicare, per esempio, quantificatori differenti a ciascuno di essi.};

\item "25[0-5]" specifica che \`{e} necessario un \textit{match} del tipo "prima cifra pari a 2, seconda cifra pari a 5 e terza cifra compresa tra 0 e 5";

\item "|" specifica \textit{OR};

\item "[01]?[0-9][0-9]?" specifica che \`{e} necessario un \textit{match} del tipo "0 o 1 o nulla; qualsiasi cifra; qualsiasi cifra o nulla".

\end{itemize}

successivamente \`{e} creato il \text{pattern} completo:


\vspace{0.5cm}

\begin{lstlisting}

Pattern p = Pattern.compile( "^(?:" + _255 + "\\.){3}" + _255 + "$");

\end{lstlisting}


\begin{itemize}

\item "\^"  specifica l'inizio dell'\textit{input};

\item "?:" specifica l'inizio di un gruppo di non "cattura";

\item "String \_255 " specifica il \textit{pattern} che deve trovare un \textit{match};

\item "\textbackslash\textbackslash "  \`{e} necessario come parte del \textit{pattern} per "\textit{escape}" del periodo, il quale altrimenti farebbe il \textit{matching} su ogni carattere.

\item "{3}" fa il \textit{matching} del gruppo, appena terminato, 3 volte; 

\item "{{+ \_255 + "\$"}}" fa il \textit{matching}, con il pattern specificato, un'altra volta.

\end{itemize}

infine viene creato l'oggetto \textit{RegexFormatter} con il \textit{Pattern} p:


\vspace{0.5cm}

\begin{lstlisting}

RegexFormatter ipFormatter = new RegexFormatter(p);

\end{lstlisting}


Solo un parametro di configurazione non pu\'{o} essere inserito manualmente: \textit{sleep condition}. Dato che per la rappresentazione di ciascuna condizione \`{e} utilizzata una lettera, \`{e} stato pensato di fornire all'utente un'esperienza semplificata tramite l'apertura di un \textit{jFrame} (come se fosse un pop-up) in cui dividere le condizioni secondo la categoria di appartenenza (condizioni sulle ore e condizioni sui giorni) e permettendo la scelta di una sola di esse per ciascuna categoria. Una volta fatta e confermata la selezione, vengono restituiti le lettere rappresentanti le condizioni scelte nella relativa {jFormattedTextField}. 


Una volta inseriti i dati, l'utente ha a disposizione due \textit{jButton} chiamati "Push" e "Pull".\\


"Push" controlla e scrive i dati inseriti dall'utente all'interno della \textit{jTextArea}, il cui scopo \`{e} quello di permettere una visualizzazione generale di tutte le informazioni inserite e, nel caso, correggerle. La \textit{jTextArea} non \`{e} editabile: questo perch\`{e} si voleva evitare che l'utente potesse cambiare il \textit{format} dei parametri di configurazione e dovendo cos\`{i} rieffettuare un altro controllo sulla loro validit\'a.\\

Una volta cliccato sul suddetto pulsante, se l'utente ha, per esempio, erroneamente inserito un valore sbagliato o dimenticato un campo non opzionale, viene visualizzato un messaggio a video di \textit{warning} con la lista degli errori e/o dimenticanze nelle \textit{jFormattedtextField}:

\begin{lstlisting}

public static List<String> warningMessage(String[] params){

List<String> warning = new ArrayList<>(); 

warning.add("Fix the following parameters:\n");

if(!Parser.checkNumber(params[1]))

if(params[2].equals("-"))

warning.add("- Contact time value not valid;\n");

else

warning.add("- Minimum contact time value not valid;\n");

if(!Parser.checkNumber(params[2]))

if(!params[2].equals("-"))

warning.add("- Maximum contact time value not valid;\n");

if(!Parser.checkNumber(params[3]))

warning.add("- Number of contacts not valid;\n");

if(!params[6].equals(" ") && !Parser.checkIPv4String(params[6]))

warning.add("- Proxy IP not valid;\n");

if(!params[7].equals(" ") && !Parser.checkPort(params[7]))

warning.add("- Proxy port not valid (choose one between 1025 and 65525);\n");

if(warning.size() == 1)

return null;

else {

warning.add("Do you want to use default settings where data is missing?");

return warning;

}

}

\end{lstlisting}.

il messaggio indirizza l'utente verso una facile soluzione dell'errore e, inoltre, nel caso di mancato inserimento di parte o di tutti i dati, permette anche di utilizzare dei valori di \textit{default} dove c\`{e} questa lacuna. Nel caso l'utente scelga di non voler utilizare i parametri di configurazione di default, la \textit{popup} col messaggio di errore si chiude, ricordando all'utente di cambiare/inserire manualmente i valori errati e/o mancati.

La generazione del messaggio avviene controllando, di nuovo, che:

\begin{itemize}

\item \textit{contactTime}, \textit{\#contacts}, \textit{proxy port} siano numeri interi;

\item \textit{proxy IP} segua una formattazione adeguata e valida;

\item nel caso di scelta di \textit{contactTime} ad intervallo, che un valore sia minore dell'altro.

\end{itemize}

Tutti i controlli sono effettuati tramite funzioni create nella classe \textit{Parser}.


Se l'utente si accorge di aver commesso un errore, "Pull" permette di prendere il \textit{set} di parametri inserito e riportarlo, campo per campo, nelle rispettive {jFormattedTextField}. A questo punto, \`{e} possibile effetuare le modifiche opportune e utilizzare di nuovo "Push" per re-importare i parametri nella \textit{jTextArea}. 


Una volta inseriti tutti i parametri di configurazione nella \textit{jTextArea}, l'utente deve salvare il file di configurazione tramite il \textit{jButton} "Save file as .txt", il quale permette di scegliere la cartella dove salvare il file, dargli un nome e confermarne o meno la correttezza. Una volta confermato, avviene l'estrazione dell'IP e della porta del \textit{proxy} (se inseriti), successivamente l'estrazione dei dati dalla \textit{jTextArea} che vengono inviati alla classe \textit{Parser} insieme al numero massimo di attributi per ciascun contatto, per essere scritti su file specificato dall'utente.


\vspace{0.5cm}

\begin{lstlisting}

public static void writeConfigurationFile(File fileToWrite, String[] params, int columns) throws IOException {

if (!fileToWrite.exists())

fileToWrite.createNewFile();

try (FileWriter fw = new FileWriter(fileToWrite.getAbsolutePath()); 

BufferedWriter bw = new BufferedWriter(fw)) {

for (int i = 0; i < params.length; i++) {

String param = params[i];

bw.write(param);

if (i < params.length - 1)

bw.newLine();

} 

bw.close();     

}

\end{lstlisting}


\textit{fileToWrite} \`{e} l'identificativo del file che \`{e} stato creato dall'utente per salvare i parametri di configurazione secondo il formato accettato dall'applicativo, \textit{params} coincide con la lista di stringhe estratte dalla \textit{jTextArea} (il primo sar\'a sempre il \textit{proxy}, se inserito dall'utente) e \textit{columns} rappresenta il numero attributi di ciascun contatto (quest'ultimo \`{e} utile per sviluppi futuri nel caso vengano aggiunti nuovi parametri di configurazione).\\


Il metodo \`{e} molto semplice, in quanto controlla l'esistenza o meno del file (in caso negativo, lo crea) e utilizza un oggetto di \textit{BufferedWriter} per scrivere riga per riga tutti i parametri inseriti dall'utente.\\


A questo punto, cliccando sul \textit{jButton} "Launch", si avvia il programma tramite i parametri inseriti nel file con formato ".txt".


\subsection{Lettura e caricamento}


Nel caso venga scelta la lettura di un file di configurazione, tramite il \textit{jButton} "...", avvia il \textit{jFileChooser}, un componente grafico simile a quello del \textit{file explorer}, con cui pu\`{o} selezionare un qualsiasi file di testo (e quindi con formato .txt) presente sulla propria macchina. Una volta selezionato, il percorso assoluto di tale file verr\`{a} visualizzato nella relativa \textit{jFormattedTextField}. A questo punto, cliccando su \textit{jButton} "Launch" si dar\`{a} avvio alla lettura del file selezionato.\\


La lettura avviene tramite \textit{BufferedReader}. Se la prima riga \`{e} il proxy, riconoscibile se il primo carattere \`{e} un carattere speciale (\$), parso la riga in IP e porta e passo direttamente alla seconda riga. 

\begin{lstlisting}.

while ((url = br.readLine()) != null) {

//Search at the beginning of the configuration file for proxy setup

[...]

if (url.charAt(0) == '$'){

String[] proxyDet = splitString(url.substring(1), ":");

URLDetails.setProxy(proxyDet[0], Integer.parseInt(proxyDet[1]));

System.out.println(proxyDet[0] + ":" + proxyDet[1]);

continue; }

\end{lstlisting}


Successivamente, a prescindere dalla presenza o meno del \textit{proxy}, si cerca una stringa che inizi con un carattere speciale (*) che indica l'inizio del singolo insieme di parametri di configurazione. La stringa immediatamente successiva \`{e} l'url da contattare e quindi se manca, il sistema esce, segnalando l'errore. 


\begin{lstlisting}

//Check URL identification char

if(!url.contains("*")){

System.err.println("Error in configuration file, aborting");

System.exit(-1);

}

\end{lstlisting}


Nel caso in cui sia presente, si scandiscono le righe successive del file (fino alla fine o alla successiva stringa che inizia per "*"), si crea una stringa del tipo "URL;minT;maxT;numC;sleepC;userAgent;", la si splitta per ";" e si convertono i parametri nel tipo di dato corretto. Una volta finito, tali valori sono utilizzati per creare un oggetto di \textit{URLDetails}. Il processo \`{e} ripetuto fino alla fine del file, portando cos\`{i} alla creazione di una lista di questi oggetti. 

\begin{lstlisting}

// Build the contact string ("URL;minT;maxT;numC;sleepC;userAgent;")

String contact = url.substring(1);

String line;

for(int i = 0; i < URLDetails.NUM_FIELDS - 1; i++){

if ((line = br.readLine()) != null)

contact = contact + delim + line;

}


//Build detail string array

String[] detail = splitString(contact, delim);


// Build URLDetails obj and add to configuration arrayList

URLDetails det = convertParam(detail);

[...]

configuration.add(det);

\end{lstlisting}



Checkbox, popup e lettura file.
Popolamento arraylist di URLDetails

\vspace{0.5cm}
\begin{lstlisting}
Parser parser = new Parser(fileConfPath);
try {
	ArrayList <URLDetails> taskList = parser.readConfigurationFile();
	Tools.schedule(taskList);
} catch (IOException ex) {
	ByobSingleton.myLogger.severe("Parser I/O exception");
}
\end{lstlisting}


\section{Lancio}
Dopo aver selezionato un file di configurazione, cliccando sul tasto \textit{Launch} viene eseguita la parte principale del progetto.
L'ArrayList di \textit{URLDetails} viene passato alla funzione \textit{Tools.schedule(ArrayList<URLDetails> task)} che, per ogni elemento estratto dall'ArrayList, crea un'istanza della classe \textit{ByobTask} (che implementa l'interfaccia \textit{Runnable}) e ne richiede la schedulazione allo \textit{Scheduler Executor Service}.

\vspace{0.5cm}
\begin{lstlisting}
public static void schedule(ArrayList <URLDetails> task) {
    for(int i = 0; i < task.size(); i++) {
	    ByobSingleton.ses.schedule(new ByobTask(task.get(i)), 0,
			    TimeUnit.MILLISECONDS);
    }
}
\end{lstlisting}


\subsection{Schedulazione dei task}
ByobTask rappresenta il singolo task che deve essere eseguito dallo scheduler; ogni task \`{e} legato ad una connessione, ovvero ad un'istanza di \textit{URLDetails}, che contiene tutti i dettagli delle comunicazioni da effettuare.
Nel metodo \textit{run()}, che viene sovrascritto dalla classe, vengono dapprima controllate le condizioni di \textit{sleep}: 
se una di queste risulta verificata il task viene ri-schedulato dopo un intervallo che va da 30 a 45 minuti, al termine dei quali viene effettuato nuovamente il check delle condizioni;
se nessuna condizione \`{e} verificata, allora viene decrementato il numero di contatti ancora da effettuare, viene ri-schedulato il task in esame ed eventualmente viene inviata una GET http alla URL target.
I dettagli del contatto avvenuto sono scritti sul file di log, cos\`{\i} come l'eventuale risposta (qualora specificato) da parte del server.

\vspace{0.5cm}
\begin{lstlisting}
public class ByobTask implements Runnable {

final static ScheduledExecutorService ses = ByobSingleton.getInstance().ses;
URLDetails contact;
[...]

   @Override
   public void run() {
   
	   if(contact.sleepMode()) {
		   /**Sleep mode: try again in 30/45 minutes */
		   int minTimeRestInterval = 30; //Minutes
		   int maxTimeRestInterval = 45; //Minutes
		   long randomInterval = minTimeRestInterval + 
		   random.nextInt(maxTimeRestInterval - minTimeRestInterval + 1);
		   [...]
		   synchronized(ses){
			   ses.schedule(this, randomInterval, TimeUnit.MINUTES);
		   }
	   } else {        
		   /**Synchronized function*/
		   if (contact.decreaseContactNum() < 0) 
			   return; 
		   else if(contact.getContactsNum() > 0){
			   [...]
			   synchronized(ses){
				   ses.schedule(this, (long)randomInterval,
				    TimeUnit.MILLISECONDS);
			   }
		   }
		   /**Write to log file*/
		   [...]
		   int code = ByobComm.httpGet(contact.getURL(),
		    contact.getUserAgent(), URLDetails.proxyIp, 
		    URLDetails.proxyPort, contact.waitForResponse);
	       [...]
	   }
	}
}
\end{lstlisting}

\subsection{Comunicazione HTTP}
I contatti (http GET) sono effettuati tramite chiamata a una funzione statica della classe \textit{ByobComm}.
Il metodo \textit{httpGet([...])} permette di specificare, oltre alla URL da contattare, anche uno user agent personalizzato, l'indirizzo ip e la porta di un server proxy che si desidera utilizzare.

\vspace{0.5cm}
\begin{lstlisting}
static int httpGet(String url, String userAgent, String proxyIp, 
					int proxyPort, Boolean waitForResponse) {  
    String charset = "UTF-8"; 
    HttpURLConnection connection;
    try {
	    if(proxyPort > 0){
		    Proxy proxy = new Proxy(Proxy.Type.HTTP, 
			    new InetSocketAddress(proxyIp, proxyPort));
		    connection = (HttpURLConnection) 
			    new URL(url).openConnection(proxy);
	    } else {
		    connection = (HttpURLConnection) new URL(url).openConnection();
	    }
	    connection.setRequestMethod("GET");
	    connection.setRequestProperty("Accept-Charset", charset);
	    
	    if(!userAgent.isEmpty())
		    connection.setRequestProperty("User-Agent", userAgent);
	    else
		    connection.setRequestProperty("User-Agent", "");
	    connection.connect();
	    int ret = waitForResponse ? connection.getResponseCode() : 0;
	    connection.disconnect();
	    return ret;
	    
    } catch (MalformedURLException ex) {
	    ByobSingleton.getInstance().myLogger.severe("MalformedURLException");
	    return -1;
    
    } catch (IOException ex) {
	    ByobSingleton.getInstance().myLogger.severe("IOException");
	    return -2; 
    }   
}
\end{lstlisting} 




